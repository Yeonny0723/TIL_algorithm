# ***Baekjoon***

<br></br>
### Q 2512. Binary Search | Parametric Search
> https://www.acmicpc.net/problem/2512 <br>


```python
N = int(input()) # 지방수
budgets = sorted(list(map(int,input().split()))) # ascending-sort
M = int(input()) # 총 예산
chk = [False] * N # 체크포인트 

def max_budget(idx):
    if M > sum(budgets):
        print(budgets[-1])
    else:
        x = (M - sum(budgets[:idx])) // (N - idx)
        
        if x > budgets[idx] and not chk[idx]:
            idx  = (idx+N)//2 # 오른쪽 절반 이동
            max_budget(idx)
            chk[idx] = True
            
        elif x < budgets[idx-1] and not chk[idx]:
            idx = idx // 2 #: 왼쪽으로 절반 이동
            max_budget(idx)
            chk[idx] = True
            
        elif not chk[idx]:
            print(x)`

idx = N // 2
max_budget(idx) # recursion error: 해결법 고민
```

- better ideation

![IMG_642DB6464303-1.jpeg](attachment:61300ddb-d8a7-48d9-89f8-d3e36a79315d.jpeg)


```python
N = int(input())
req = list(map(int,input().split()))
M = int(input())

# (1) ***탐색 범위 설정***
lo = 0
hi = max(req)
mid = (lo + hi) // 2
ans = 0 


def is_possible(mid): # parametric search(True/False) 함수 구현 
    # 얼마든지 parametric search + 다른 알고리즘 문제가 혼합되어 나올 수 있음. 
    return sum(min(r, mid) for r in req) <= M


# (2)***언제까지 탐색할지 조건 설정***
while lo < hi: # 언젠가는 만나게 될 것
    print('lo:',lo,'mid',mid,'hi',hi,'ans',ans)
    if is_possible(mid): 
        lo = mid + 1
        ans = mid
    else:
        hi = mid - 1

    mid = (lo + hi) //2

print(ans) # optimazation problem. 문제 상황을 만족하는 변수의 최대 최소값을 구하는 문제 

```

<br></br>
### Q10815. Binary Search | Parametric Search
> https://www.acmicpc.net/problem/10815 <br>


```python

```
